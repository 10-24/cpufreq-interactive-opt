# cpufreq_interactive 仿真优化器  

程序版本：20171016  
尽管最近又做了一波更新，但是仍然有很多需要完善的地方。  

程序包含以下组件/环节：  
1. 采样的负载序列
2. SOC功耗模型，即频率-功率的对应表
3. interactive参数生成器
4. interactive调速器仿真运行
5. 仿真运行的数据统计，比如卡顿程度
6. 对数据统计的评分函数
7. 与schutil的相对功耗
8. 输出为CSV

目前进展：
1. 采样的负载序列  
目前是通过Trepn Profier做的采样，时间间隔为100ms。显然对于调速器20ms的周期来说太长了，不能反映更小颗粒度下负载的变化。  
可能的解决方案有：
    1. 编写批处理，从Linux层获取CPU的使用率变化，还没有学习
    2. 使用android提供的dumpsys gfxinfo渲染分析，可能精度不足

2. SOC功耗模型  
根据WP7吧各位大佬以及Anandtech提供的功耗分析数据，基本OK。  
但是例如835或者820小核心的功耗数据并没有，但不是很关键。

3. interactive参数生成器  
目前是枚举法，遍历所有可能。  
但是现在看下来，比较好的参数有些一致性，可以做收敛。  
在above_hispeed_delay做了掩码，消除了一些重复的参数生成。  
这方面有待挖掘，目前枚举的复杂度量级太高(n^5)，以至于难以做广度和深度的探究。

4. interactive调速器仿真运行  
目前欠缺boostpluse_duration的实现。  
除此以外完成度很好，对interactive流程有完整的模拟。  
效率方面对高频调用做了内联，优化的空间看起来不大。  
解释器使用了Pypy 3(JIT)，大约是12x的性能，但是不能解决过高的时间复杂度。  

5. 仿真运行的数据统计  
做了卡顿1帧（30fps），2帧（15fps），3+帧（stuck）的计数。  
以及根据不同CPU使用率的计数，对应到不同的出现的卡顿几率。  
以后根据评分函数加入方差一类的钩子吧。  

6. 对数据统计的评分函数  
啊，我不懂数学工具。  
目前的评分公式是：  
    40% 平均一次卡顿内包含的帧数  
        log10((占用率99%次数 - fps30次数 - fps15次数*2) / 卡顿次数 - 1)  
        -1 用于平移横轴，平均卡顿帧数从3帧开始，3帧附近变化率大  
    25% 总拥塞次数  
        占用率99%次数 / 1000 ，归一化处理 
    20% 总卡顿次数  
        sqrt(卡顿次数 / 100)，总卡顿次数越大越不敏感  
    10% fps15  
        fps15次数 / 125，归一化处理  
    5%  fps30  
        fps30次数 / 250，归一化处理  
不就是加权平均值么hhh。  
有待重做，上面的难以反映流畅度感受，但总比没有好。  

7. 与schutil的相对功耗  
已完工。  
也就是相对于理想状态，知道下一周期的负载值，算出给多大的性能。  

8. 输出为CSV  
已完工。

